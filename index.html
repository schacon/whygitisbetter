<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Por qué Git es mejor que X</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection">
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print">    
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"></script>
	
	<style type="text/css">
		html { overflow-y: scroll; }
		.header h1 { font-size: 3.5em; color: #666; }
		.expand_collapse_links { text-align: center; }
		.expand_collapse_links a { color: #555; }
		img { margin-bottom: 10px; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
    .section h2 a { color: #333; text-decoration:none; display: block; }
		.section { margin-bottom: 20px; }
		.contents { padding: 0 10px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; }
	</style>
	
</head>

<body>

	<div class="container">

			<br/>
			
	    <div class="span-24 header">
				<table width="100%">
					<tr><td>
        		<h1>Por qué Git es mejor que X</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg">hg</span>
							<span class="lang bzr">bzr</span>
							<span class="lang svn">svn</span>
							<span class="lang perforce">perforce</span>
						</div>
						<img style="float: right" src="images/wherex.gif">
					</td></tr>
					</table>
	    </div>

	    <div class="span-24">
					<div class="text intro">
						Este sitio existe porque últimamente me parece que paso demasiado
                        tiempo defendiendo a los usuarios de Git frente a acusaciones de
                        fanatismo, seguisdimo y fe ciega. Así que aquí veremos por qué la gente
                        está pasándse de X a Git y por qué tú también deberías. Sólo haz clic
                        en una razón para verla.
					</div>
					
					<div class="expand_collapse_links" style="display: none;">
					  <a href="#" class="expand_all">Ver todas</a> |
					  <a href="#" class="collapse_all">Cerrar todas</a>
					</div>
	    </div>

			<br/>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="cheap-local-branching" href="#cheap-local-branching">Ramas locales sin coste</a>
	        </h2>
					<div class="contents">
						
						<div class="text">
							Posiblemente la razón más fuerte a favor de Git que realmente lo
                            hace destacar de casi cualquier otro SCV es su modelo de ramas. Es
                            totalmente diferente de todos los demás con los que lo estamos
                            comparando, la mayoría de los cuales recomiendan que la mejor rama
                            es básicamente una copia del repositorio en un nuevo directorio.
						</div>
						
						<div class="text">
							Pero Git no funciona así. Git te permitirá tener múltiples ramas
                            locales que pueden ser totalmente independientes entre sí y se
                            tarda segundos en crear, fusionar, o borrar estas líneas de
                            desarrollo.
						</div>
						
						
						<div class="text">
							Lo que quiere decir que puedes hacer cosas como :
							<ul>
								<li>
									Crear una rama para probar una idea, hacer varias entregas
                                    un par de veces, volver al punto desde el cual bifurcaste,
                                    aplicar un parche y volver a donde estabas experimentado y
                                    fusionarlo.
								</li>
								<li>
									Tener una rama que siempre contiene sólo lo que va a
                                    producción, otra en la que acumulas el trabajo para
                                    testear y varias ramas más pequeñas para el trabajo del
                                    día a día.
								</li>
								<li>
									Crear nuevas ramas para cada una de las nuevas
                                    funcionalidades en las que estés trabajando, de forma que
                                    puedas conmutar entre ellas y borrarlas cuando su
                                    funcionalidad ha sido propagada a la rama principal.
								</li>
								<li>
									Crear una rama en la que experimentar, darte cuenta de que
                                    no va a ninguna parte y borrarla, abandonando todo el
                                    trabajo - sin que nadie más lo vea (incluso aunque hayas
                                    entregado otras ramas mientras tanto)
								</li>
							</ul>
						</div>
						
						<img src="images/branches.png">
						
						<div class="text">
							Es importante el que, cuando uno entrega sus cambios a un
                            repositorio remoto, <em>no</em> tienes que subir todas tus ramas:
                            puedes compartir sólo una de tus ramas y no todas. De esta forma
                            la gente tiende a sentirse libre para probar nuevas ideas sin
                            preocuparse de tener un plan de cómo y cuándo van a mezclar sus
                            cambios o compartirlos con otros.
						</div>
						
						<div class="text">
							Se <em>pueden</em> encontrar maneras de hacer algunas de estas
                            cosas en otros sistemas, pero el trabajo necesario es mucho más
                            complicado y dado a error. Git hace que este proceso sea
                            increíblemente sencillo y cambia la forma en la que trabajan los
                            desarrolladores que aprenden a usarlo.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif">
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif">
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif">
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif">
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif">
						</div>
					</div>
	    </div>
				
	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
	        <h2>
          <a name="everything-is-local" href="#everything-is-local">Todo es local</a>
	        </h2>
					<div class="contents">	

						<div class="text">
							Esto es básicamente cierto en todos los SCV distribuidos, pero en
                            mi mi experiencia lo es mucho más con Git. Aparte de 'fetch',
                            'pull' y 'push' hay muy pocos comandos que trabajen con cualquier
                            cosa que no sea tu disco duro.
						</div>

						<div class="text">
							Esto no sólo hace que todo vaya mucho más rápido que de costumbre,
                            también te permite trabajar cuando estés sin conexión. Que a lo
                            mejor no te parece gran cosa, pero a mí al menos me ha llegado a
                            sorprender la cantidad de veces que realmente trabajo sin
                            conexión. El poder hacer ramas, mezclarlas, y navegar por la
                            historia de mi proyecto mientras se está en un avión o un tren es
                            realmente muy productivo.
						</div>
						
						<center><img width="500px" src="images/local-remote.png"></center>

						<div class="text">
							Incluso en Mercurial comandos comunes como 'incoming' y
                            'outgoing' tocan al servidor, mientras que con Git puedes hacer
                            'fetch' de toda la información del servidor antes de quedarte sin
                            conexión y hacer comparaciones, merges, y ver logs de todos los
                            datos que están en el servidor aunque no pertenezca a tus ramas
                            locales.
						</div>
												
						<div class="text">
							Lo que quiere decir que es muy fácil tener copias de no sólo todas
                            tus ramas, sino también de todas las ramas que los demás que
                            trabajan contigo proyecto hayan ido subiendo al repositorio de
                            Git.
						</div>
						
					</div>
	    </div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
	        <h2>
          <a name="git-is-fast" href="#git-is-fast">Git is Rápido</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							Git es rápido. Todo el mundo, hasta los más acérrimos usuarios del
                            resto de sistemas lo reconoce. Esto se debe, comparado con SVN y
                            Perforce, a que todas las operaciones se hacen localmente. Sin
                            embargo cuando se compara con otros SCVs distribuidos, Git también
                            es veloz.
						</div>
					
						<div class="text">
							Es posible que esto se deba en buena parte a que fue construido
                            para trabajar en el kernel de Linux, lo que quiere decir que desde
                            el primer día ha tenido que mover de manera efectiva repositorios
                            de gran tamaño. Otra razón es que Git está escrito en C, y otra
                            razón más es que, en mi experiencia, los desarrolladores
                            principales de Git están muy preocupados por la velocidad.
						</div>

						<div class="text">
							A continuación veremos algunas pruebas que realicé en tres copias
                            del código fuente de django en 3 sistemas diferentes: Git,
                            Mercurial y Bazaar. También hice alguna prueba con SVN, pero
                            creedme cuando os digo que es más lento - básicamente es añadirle
                            la latencia de red a los números de Bazaar.
						</div>
						
						<table>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:2,5,60&chds=0,60&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Init">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:85,3,23&chds=0,100&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Add">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:45,194,1474&chds=0,1474&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Status">
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,21,142&chds=0,142&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Diff">
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&chs=190x275&chd=t:1,123,390|11,946,820&chds=0,1210&chxt=x&chco=4d89f9,c6d9fd&chl=git|hg|bzr&chtt=Branching">
						</td></tr>
						<tr><td nowrap>
							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:5,120,189&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Tag">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:7,26,90&chds=0,90&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Log">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:124,125,230&chds=0,230&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Lg)">

							<img src="http://chart.apis.google.com/chart?cht=bvs&chs=100x125&chd=t:8,51,113&chds=0,113&chxt=x&chco=4d89f9&chl=git|hg|bzr&chtt=Commit (Sm)">
						</td></tr>
						</table>
						
						<div class="text">
							El resultado final es que para todo menos para añadir nuevos
                            archivos, Git es el más rápido (también commits muy grandes,
                            empatado con Git, pero la entrega que hice era tan grande que es
                            bastante raro que alguna vez tengas que hacer algo parecido - los
                            commits normales son mucho más rápidos en Git)
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Inicialización</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Añadir</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Etiquetar</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Entrega (Grande)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Entrega (Pequeña)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Rama (en frío)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Rama (en caliente)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
							Los tiempos de creación de rama en frío y en caliente se
                            corresponden, respectivamente, con el tiempo empleado en la
                            primera y segunda vez que bifurqué el repositorio - de forma que
                            en el segundo caso la rama se hizo con la caché del disco
                            caliente.
						</div>

						<div class="text">
							Nótese que aunque los números para el añadido de ficheros son
                            mucho más lentos, se trataba de una operación masiva (más de 2000
                            archivos) Para lo que la mayor parte de la gente hace, el añadir
                            cosas al repositorio sólo lleva una fracción de segundo. El resto
                            de operaciones es bastante más indicativo de las cosas que uno
                            realmente termina haciendo en el día a día.
						</div>
					
					
					<div class="text">
							No es nada difícil volver a generar estas medidas. Simplemente
                            clona el proyecto Django en cada uno de los sistemas e intenta
                            ejecutar los mismos comandos en cada uno
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
	    </div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
	        <h2>
          <a name="git-is-small" href="#git-is-small">Git es Pequeño</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							Git es realmente hábil a la hora de ahorrar espacio. En general tu
                            repositorio Git será poco más grande que una copia de trabajo de
                            SVN - y en algunos casos es posible que sea más pequeño (parece
                            ser que hay un montón de cosas que acaban en los directorios .svn)
						</div>
					
						<div class="text">
							Los siguientes tamaños fueron obtenidos de copias del proyecto
                            Django en cada uno de sus mirrors de Git semi-oficiales en algún
                            punto de su historia.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>Bzr*</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Sólo el repo</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td>89M</td>
								<td></td>
							</tr>
							<tr>
								<td>Todo el directorio</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td>108M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
						<div class="text"><small>
							* el segundo número de Bzr es después de ejecutar 'bzr pack', que
                            pensé que lo haría más pequeño pero por alguna razón lo hizo
                            mucho mucho más grande.
						</small></div>
						
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
	        <h2>
          <a name="the-staging-area" href="#the-staging-area">El área de montaje</a>
	        </h2>
					<div class="contents">
						<div class="text">
							Al contrario que otros sistemas, Git tiene lo que denomina "área
                            de montaje", o "índice" que es un área intermedia donde puedes
                            configurar lo que contendrá el aspecto que tendrá tu entrega antes
                            de hacer el commit.
						</div>
						<div class="text">
							Lo mejor del área de montaje, y que marca la diferencia entre git
                            el resto de herramientas, es que puedes fácilmente montar algunos
                            de tus ficheros según terminas con ellos y después entregarlos sin
                            tener que enviar todos los archivos modificados en tu directorio
                            de trabajo y sin tener que listarlos en la línea de comandos
                            durante la entrega.
						</div>
						<center><img src="images/index1.png"></center>
						
						<div class="text">
							Esto también te permite preparar sólo fragmentos de archivos que
                            han sido modificados.  Por ejemplo,  montas para entregar sólo los
                            cambios al principio de un archivo que has estado modificando pero
                            no los cambios del final.
						</div>

						<div class="text">
							Por supuesto, Git también hace que sea fácil ignorar esta
                            funcionalidad en caso de que no queramos tanto nivel de control -
                            simplemente añade '-a' al commando 'commit'.
						</div>
						
						<center><img src="images/index2.png"></center>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="distributed" href="#distributed">Distribuido</a>
	        </h2>

					<div class="contents">

					  <div class="text">
						Una de las cosas más chulas de cualquier sistema distribuido de
                        control de versiones, incluido Git, es que es distribuido. Esto quiere
                        decir que en lugar de hacer un "checkout" de la punta del código,
                        haces un "clon" del repositorio en su totalidad.
            </div>
            <div class="text">
						Lo que quiere decir que incluso si trabajas de manera centralizada,
                        cada usuario tiene lo que en esencia es una copia completa del
                        servidor principal, y cualquiera de ellas podría ser recuperada para
                        reemplazarlo en caso de caída o corrupción. Básicamente, no hay un
                        punto de fallo único con git... a no ser que haya un punto único.
            </div>

            <div class="text">
						Además esto tampoco ralentiza demasiado las cosas. En término medio un
                        checkout de SVN es más rápido que cualquiera de los SCV distribuidos,
                        pero por poco. Además, de entre los sistemas distribuidos git fue el
                        más rápido en mis pruebas.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&chs=200x150&chd=t:120,144,311,64&chds=0,320&chco=4d89f9&chl=git|hg|bzr|svn&chtt=Clone">
							</td><td width="80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
       	<h2>
        <a name="any-workflow" href="#any-workflow">Cualquier flujo de trabajo</a>
       	</h2>

				<div class="contents">
					
					<div class="text">
						Una de las cosas que más sorpenden de Git es que debido a su
						naturaleza distribuida y a su super-sistema de ramas se puede 
						implementar fácilmente prácitcamente cualquier flujo de trabajo que
						se nos ocurra.
					</div>
					
					<h3>Al estilo Subversion</h3>
					

					<div class="text">
						Una forma de trabajo muy común, especialmente entre aquellos que
						se pasan de un sistema no distribuido es un flujo de trabajo 
						centralizado.  Git no permite hacer subir los cambios al servidor 
						si alguien lo ha hecho desde la última vez que nos bajamos los
						últimos cambios, de forma que un modelo centralizado donde todos
						los desarrolladores entregan al mismo servidor funciona sin
						mayor inconveniente.
					</div>
					
					<center><img src="images/workflow-a.png"></center><br/>
					
					<h3>Al estilo Responsable de Integración</h3>

					<div class="text">
						Otra forma muy común de trabajar con Git es donde exista un 
						Responsable de Integración - una persona que entrega al repositorio
						'bendecido', y después un número de desarrolladores se copian ese
						repositorio y hacen sus cambios en él le piden al integrador que
						integre sus cambios.  Este es el tipo de modelo de desarrollo que
						se suele usar en repositorios de software abierto o en GitHub.
					</div>

					<center><img src="images/workflow-b.png"></center><br/>

					<h3>Al estilo Dictador y Tenientes</h3>

					<div class="text">
						En proyectos más grandes, los desarrolladores pueden organizarse de
                        forma similar a como lo hacen en el kernel de Linux, donde hay gente
                        que está a cargo de un subsistema específico del proyecto (los
                        tenientes) e integran todos los cambios que tienen que ver con ese
                        subsistema. Después otro integrador (el dictador) puede recoger los
                        cambios únicamente de sus tenientes y subirlos al repositorio
                        principal el cual todo el mundo vuelve a clonar.
					</div>

					<center><img src="images/workflow-c.png"></center><br/>
					
					<div class="text">
						Y de nuevo Git es totalmente flexible en este aspecto de forma
						que uno puede mezclar y escoger el flujo de trabajo que mejor
						se adapte a sus necesidades.
          </div>
					
				</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang bzr">bzr</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

        <h2>
        <a name="github" href="#github">GitHub</a>
        </h2>
				
				<div class="contents">

          <img style="float:right; padding:10px" src="images/octocat.png">

					<div class="text">
						En esto <em>podría ser</em> que yo no sea del todo imparcial 
						porque trabajo en <a href="http://github.com">GitHub</a>, 
						pero quiero añadir esta sección de todas formas porque hay mucha
						gente que afirma que GitHub es la razón por la que escogieron Git.
					</div>

					<div class="text">					
						Y GitHub es para muchos una razón para escoger Git porque se parece
						más a una red social de código que un mero sitio de alojamiento.
						Uno se encuentra con otros desarrolladores o proyectos que son
						similares a lo que está haciendo y es muy fácil bifurcar y contribuir,
						creándose una comunidad vibrante en torno a Git y los que proyectos
						en los que la gente lo usa.
					</div>
					
					<div class="text">					
						Existen otros servicios, tanto para Git como para otros SCVs, pero 
						hay pocos que estén orientados a los usuarios desde un punto de
						vista social, y ninguno de ellos se acerca al número de usuarios
						que tiene GitHub.  Este aspecto social es decisivo, y esta junto
						con el resto de funcionalidades de arriba hace que trabajar con Git
						y GitHub sea una gran combinación para desarrollar rápidamente
						proyectos de código abierto.
					</div>

					<div class="text">					
						Este tipo de comunidad no está disponible en ninguno de los otros
                        SCVs. Simplemente.
          </div>
					
					<div class="tweets">
						<img alt='puls twitter' width="300" src="http://twictur.es/i/1022858126.gif">
						<img alt='twitter' width="300" src="http://twictur.es/i/1022857633.gif">
					</div>
				</div>
	    </div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
        <h2>
        <a name="easy-to-learn" href="#easy-to-learn">Fácil de Aprender</a>
        </h2>
        
				<div class="contents">
					<div class="text">								
						Esto solía no ser cierto - en los comienzos de Git no era tanto
						un sistema de control de versiones como un puñado de herramientas que
						permitían hacer tareas de sistema de ficheros de manera distribuida.
						Sin embargo a día de hoy el conjunto de comandos y la curva de
						aprendizaje de Git son bastante parecidos a la de cualquier SCV, e
						incluso mejor en algún caso.
					</div>

					<div class="text">				
						Como es difícil probar esto de manera objetiva sin algún tipo de
						estudio simplemente mostraré las diferencias entre el menú de ayuda
						por defecto de Mercurial y Git.  He resaltado los comandos que son
						idénticos (o casi) entre los dos sistemas.  (En Hg, si escribes
						'hg help' te sale una lista de casi 40 comandos)
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Ayuda de Mercurial</h3>
<pre>
<span class="compare">add</span>        add the specified files ...
<span class="compare">annotate</span>   show changeset informati...
<span class="compare">clone</span>      make a copy of an existi...
<span class="compare">commit</span>     commit the specified fil...
<span class="compare">diff</span>       diff repository (or sele...
export     dump the header and diff...
<span class="compare">init</span>       create a new repository ...
<span class="compare">log</span>        show revision history of...
<span class="compare">merge</span>      merge working directory ...
parents    show the parents of the ...
<span class="compare">pull</span>       pull changes from the sp...
<span class="compare">push</span>       push changes to the spec...
<span class="compare">remove</span>     remove the specified fil...
serve      export the repository vi...
<span class="compare">status</span>     show changed files in th...
update     update working directory
</pre>

					</td><td valign="top">
						
<h3>Ayuda de Git</h3>
<pre>
<span class="compare">add</span>        Add file contents to the index
<span class="compare">bisect</span>     Find the change that introduce...
<span class="compare">branch</span>     List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>      Clone a repository into a new ...
<span class="compare">commit</span>     Record changes to the repository
<span class="compare">diff</span>       Show changes between commits, ...
fetch      Download objects and refs from...
grep       Print lines matching a pattern
<span class="compare">init</span>       Create an empty git repository
<span class="compare">log</span>        Show commit logs
<span class="compare">merge</span>      Join two or more development h...
mv         Move or rename a file, a direc...
<span class="compare">pull</span>       Fetch from and merge with anot...
<span class="compare">push</span>       Update remote refs along with ...
rebase     Forward-port local commits to ...
reset      Reset current HEAD to the spec...
<span class="compare">rm</span>         Remove files from the working ...
show       Show various types of objects
<span class="compare">status</span>     Show the working tree status
<span class="compare">tag</span>        Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">										
					Antes de la versión 1.6 de Git todos los comandos estaban en el 
					path ejecutable, lo cual confundía a mucha gente.  Aunque Git sigue
					reconociendo todos estos comandos el único comando en el path ahora
					es 'git'.  Así que si uno compara Git con Mercurial tienen un conjunto
					de comandos y sistema de ayuda muy parecido - hay poca diferencia
					desde el punto de vista de interfaz de usuario para un principiante.
				</div>
				
				<div class="text">										
					Hoy es difícil sostener que Mercurial o Bazaar sean mucho más fáciles
					de aprender que Git.
				</div>
				
				</div>
				
	    </div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

		<br/>

    <div class="span-24">					
				<div class="expand_collapse_links" style="display: none;">
				  <a href="#" class="expand_all">Ver todas</a> |
				  <a href="#" class="collapse_all">Cerrar todas</a>
				</div>
    </div>
    
    <br />
		
    <div class="span-24 footer">
			Este site está construido y mantenido por <a href="http://github.com/schacon">Scott Chacon</a>, empleado de <a href="http://github.com">GitHub</a>.<br/>
			Si no estás de acuerdo con algo de lo aqui expuesto y es por una buena
			razón por favor <a href="mailto:schacon@gmail.com">envíame un correo</a> para
			que pueda corregirlo.<br/>
			El código fuente en inglés de site está <a href="http://github.com/schacon/whygitisbetter">en GitHub</a> - sírvete de enviar parches si quieres mejorarlo.
		</div>

	</div>

<script>
	$(function() {
		$('.section > .contents').hide();
		$('.contents > .tweets').hide();
		$('.expand_collapse_links').show();
		$('.expand_collapse_links > .expand_all').click(function() {
		  $('.section > .contents').show();
		});
		$('.expand_collapse_links > .collapse_all').click(function() {
		  $('.section > .contents').hide();
		});
		$('.section > h2').click(function() {
			$(this).next().slideToggle();
		})
		
		if (document.location.hash) {
		  $('.section > h2 > a[name=' + document.location.hash.substring(1) + ']').parent('h2').click()
		}
	})
</script>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

