<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Why Git is Better Than X</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection" />
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print" />
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js" type="text/javascript"></script>
	
	<style type="text/css">
		html { overflow-y: scroll; }
		body { margin-top: 1.5em; }
		.header h1 { font-size: 3.5em; color: #666; }
		.expand_collapse_links { text-align: center; margin-bottom: 1.5em; display: none; }
		.expand_collapse_links a { color: #555; }
		img { margin-bottom: 10px; }
		.center { text-align: center; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
    .section h2 a { color: #333; text-decoration:none; display: block; }
		.section { padding-bottom: 2px; }
		.contents { padding: 0 10px; width: 610px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.nowrap { white-space: nowrap; }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; } 
		.footer-lang { text-align: center; color: #443; background-color: #dda; padding: 5px; font-size: 90%; }
		.footer-lang a { color: #330; } 
    .footer-badges { text-align: center; }
    .footer-badges a { color: #777; }
		.lang a {color: inherit; text-decoration: none;}
    .note { text-decoration: italic; color: #666; padding: 1em; }
	</style>
	
</head>

<body>
	<div class="container">

	    <div class="span-24 header">
				<table width="100%">
					<tr><td>
        		<h1>Why Git is Better than X</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg">hg</span>
							<span class="lang bzr">bzr</span>
							<span class="lang svn">svn</span>
							<span class="lang perforce">perforce</span>
						</div>
						<img style="float: right" alt="where &quot;x&quot; is one of" src="images/wherex.gif" />
					</td></tr>
					</table>
	    </div>

	    <div class="span-24">
					<div class="text intro">
						최근 나는 슈퍼 울트라 극성주의자<sup>fanboyism, bandwagonism and koolaid-thirst</sup>들로부터  Gitster들을 옹호하는데 지쳐서 이 사이트를 만들었다. 나는 사람들이 왜 Git으로 갈아타는지를 정리했다. 클릭해보라.
						
					</div>
					
					<div class="expand_collapse_links">
					  <a href="#" class="expand_all">모두 펴기 </a> |
					  <a href="#" class="collapse_all">모두 숨기기</a>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="cheap-local-branching" href="#cheap-local-branching">값 싼 브랜칭</a>
	        </h2>
					<div class="contents">
						
						<div class="text">
							다른 SCM에 비해 Git의 가장 큰 특징은 아마도 브랜치 모델일 것이다. Git은 내가 여기서 비교하고자 하는 다른 모델들과는 완전히 다르다. 대부분이 권장하는 궁극의 브랜치는 새 디렉토리로 레파지토리를 통째로 복사하는 것이다.
						</div>
						
						<div class="text">
							하지만 Git은 그렇게 동작하지 않는다. Git에서는 여러 개의 로컬 브랜치를 가질수 있으며 그 로컬 브랜치들은 서로 완벽하게 독립적이기 때문에 개발 중 수행하는 생성, 머지, 삭제 명령도 독립적으로 수행된다.	
						</div>
						
						
						<div class="text">
							Git으로는 다음과 같은 일들을 할 수 있다:
							<ul>
								<li>아이디어를 실험하기 위해 브랜치를 만들고, 몇 번 커밋을 하고, 원래 것으로 돌아가, 패치를 적용한다. 다시 실험중인 브랜치로 돌아가 그것을 머지한다.
								</li>
								<li>제품으로 출시하기 위한 브랜치는 하나만 가질 수 있지만 그외 다른 목적의 브랜치는 마음것 만들 수 있다. 테스트나 일상적인 업무를 위한 브랜치를 만들어 작업하고 그 것을 머지한다.
								</li>
								<li>당신이 만들고 있는 이슈마다 브랜치를 새로 만들고 그 브랜치들 사이들 오가며 작업할 수 있다. 그리고 그 브랜치를 마스터 브랜치로 머지한 후에 그 브랜치들을 삭제한다.
								</li>
								<li>실험용 브랜치를 만들고 쓸모가 없으면 바로 삭제한다. (그 동안 다른 브랜치들을 푸시했었더라도) 실험은 버려졌기 때문에 아무도 모른다.
								</li>
							</ul>
						</div>
			
						<img src="images/branches.png" alt="branches flowchart"/>
						
						<div class="text">
							중요한 것은 원격의 레파지토리에 푸시할 때 가지고 있는 브랜치 전부를 푸시하지 않는 점이다. 가지고 있는 브랜치들 중 하나만 공유할 수 있다. 그래서 사람들은 언제, 어떻게 브랜치를 머지하고 공유해야 할지에 대한 고민없이 쉽게 새로운 아이디어를 실험할 수 있다.
						</div>
						
						<div class="text">
							다른 시스템과 함께 Git을 사용할 방법이 있지만 매우 어렵고 에러나기 쉽다. Git을 배우면 이 과정이 매우 쉬워지고 일하는 방식도 변화한다.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif" />
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif" />
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif" />
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif" />
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif" />
						</div>
					</div>
	    </div>
				
	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
	        <h2>
          <a name="everything-is-local" href="#everything-is-local">역사는 로컬에서</a>
	        </h2>
					<div class="contents">	

						<div class="text">
							이 것은 모든 분산 SCM에도 해당하는 이야기지만 나는 주로 Git을 많이 사용한다. Git은 외부 요소가 매우 적다. 내 하드디스크 세상 밖으로 소통하는 방법은 'fetch', 'pull', 'push'밖에 없다.
						</div>

						<div class="text">
							이 것은 우리가 해왔던 것 보다 모든 명령의 수행 속도를 빠르게 해줄뿐만 아니라 오프라인에서도 작업할 수 있도록 해준다. 실제로 아무것도 아닐 것 같지만 나는 내가 자주 오프라인으로 작업하고 있는 것을 발견하곤 항상 매우 놀란다. 비행기나 기차안에서도 오프라인으로 브랜치, 머지, 커밋하고 프로젝트의 히스토리를 살펴볼 수 있다는 것은 매우 생산적이다. 
						</div>
						
						<div class="center"><img style="width: 500px" src="images/local-remote.png" alt="local repo to remote repo flowchart" /></div>

						<div class="text">
							심지어 Mercurial은 incoming과 outouing같은 명령어는 서버와 통신해야 한다. 하지만 Git은 서버에 있는 데이터를 로컬 브랜치로 fetch한다. fetch를 한 후에 오프라인으로도 서버에 있는 데이터와 비교, 머지, 로그 등의 일을 할 수 있다.   
						</div>

						<div class="text">
							즉, Git 레파지토리에 있는 작업물들을 헝클지도 않으면서 나와 함께 일하는 동료들은 모두 자신만의 브랜치를 매우 쉽게 만들 수 있다.
						</div>
						
					</div>
	    </div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
	        <h2>
          <a name="git-is-fast" href="#git-is-fast">Git is Fast/Git은 빠르다</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							모두가 Git의 장점으로 'Git은 빠르다'라고 내세운다. 다른 SCM의 맹신자들도 Git이 빠르다고 인정한다. Git의 모든 오퍼레이션은 로컬에서 수행된다. 네트워크가 필요한 SVN과 Perforce이 뛸 때 날고 있는 셈이다. 게다가 Git은 로컬에서 명령을 수행하는 다른 DSCM과 비교해도 빠르다.
						</div>
					
						<div class="text">
							처음 개발할때 부터 리눅스 커널에 사용할 목적이 였기 때문에 규모가 큰 레파지토리일 수록 더욱 효과적이다. 게다가 Git은 C로 작성돼있어서 고수준 언어가 만들어내는 오버헤드도 없다. Git을 만든 선구자들은 '빠른 것'을 설계 목표중 하나로 삼았다.
						</div>

						<div class="text">
							나는 몇 가지 벤치마크 테스트를 진행했다. Git, Mercurial, Bazaar 이렇게 세가지 SCM에 각각 Django source code를 올려놓고 테스트를 했다. 나는 또한 SVN으로도 이 중 몇가지 테스트를 진행했다. 내가 장담컨데 SVN은 느리다. 기본적으로 Bazaar의 결과에 네트워크 레이턴시(Latency)를 더해야 한다.
						</div>

            <table>  
						<tr><td class="nowrap">
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:2,5,60&amp;chds=0,60&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Init" alt="init benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:85,3,23&amp;chds=0,100&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Add" alt="add benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:45,194,1474&amp;chds=0,1474&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Status" alt="status benchmarks" />
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,21,142&amp;chds=0,142&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Diff" alt="diff benchmarks" />
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&amp;chs=190x275&amp;chd=t:1,123,390|11,946,820&amp;chds=0,1210&amp;chxt=x&amp;chco=4d89f9,c6d9fd&amp;chl=git|hg|bzr&amp;chtt=Branching" alt="branching benchmarks" />
						</td></tr>
            <tr><td class="nowrap">
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,120,189&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Tag" alt="tag benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:7,26,90&amp;chds=0,90&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Log" alt="log benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:124,125,230&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit+(Lg)" alt="large commit benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:8,51,113&amp;chds=0,113&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit+(Sm)" alt="small commit benchmarks" />
						</td></tr>
						</table>
						
						<div class="text">
							결론부터 말하자면 파일을 새로 추가하는 경우를 제외하면 Git은 항상 빠르다.(물론 정말정말 큰 데이터를 커밋하는 경우는 Hg가 제일 빠르다. 그러나 내가 테스트한 크기조차도 보통은 경험할 수 없다. 그러니까 대부분의 경우는 Git이 더 빠르다.)
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Init</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Add</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Tag</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Commit (Large)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Commit (Small)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Branch (Cold)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Branch (Hot)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
							The cold and hot branching numbers are the numbers for the first
							and second times that I branched a repo&mdash;the second number being
							a branch with a hot disk cache.
							<hr />
							코드 브랜칭과 핫 브랜칭에 대한 결과는 내가 처음 브랜치를 만들 었을 때와 두번째 만들 었을 때를 의미한다. 핫 브랜칭은 핫 디스크 캐시를 이용한 것이다.
						</div>

						<div class="text">
							<hr />
							테스트 결과에서 'add'의 경우는 매우 느리다. 하지만 이 것은 파일 2000개가 넘는 경우에나 해당된다. 대부분의 사람들은 하루를 기준으로 일을 하는데 보통 'add'는 순식간에 이루어진다. 여기서 진행한 다른(라지 커밋은 제외한) 테스트 결과들은 우리가 날마다 실제로 하는 패턴들이다. 
						</div>
					
					
					<div class="text">
						이 테스트를 재현하는 것은 어렵지 않다. 단순히 각 시스템마다 다음과 같은 명령어를 수행하여 Django 프로젝트의 클론을 만들면 된다.
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
	    </div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
	        <h2>
          <a name="git-is-small" href="#git-is-small">Git은 작다.</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							Git은 디스크 공간을 적게 차지한다. Git 디렉토리는 일반적으로 SVN checkout한 것보다 별반 차이 없다. 어떤 경우에는 SVN의 것보다 작다(.svn 디렉토리에는 뭔가 무진장 많다는 것만은 분명이다.).
						</div>
					
						<div class="text">
							다음은 Django project의 클론에 대한 것이다. 동일한 버전을 기준으로 비공식(semi-official) Git 미러를 통해 만들었다.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Repo Alone</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td></td>
							</tr>
							<tr>
								<td>Entire Directory</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
	        <h2>
          <a name="the-staging-area" href="#the-staging-area">Staging 영역</a>
	        </h2>
					<div class="contents">
						<div class="text">
							다른 시스템과 달리 Git은 "staging area" 혹은 "index"라고 부르는 것이 있다. 커밋할 것 같은 파일을 넣고 관리하는 일종의 중간 영역이다.
						</div>
						<div class="text">
							staging area가 멋있는 점은 일을 끝내자 마자 쉽게 파일을 스테이지할 수 있고 커밋할 때 워킹 디렉토리에서 수정된 모든 파일을 커밋되지 않는다는 점이다. 또한 커밋할 때까지 명령어로 staging area를 관리할 수 있다.
						</div>
						<div class="center"><img src="images/index1.png" alt="add commit workflow diagram" /></div>
						
						<div class="text">
						  우리는 수정한 파일의 일부만 스테이지할 수도 있다. 무언가 빼먹고 커밋하기 전에 논리적으로 무관한 파일을 걸러낼 필요가 없어졌다. 지금은 그냥 지금 커밋하는데 필요한 파일을 스테이지하고 다음 커밋에 필요한 다른 파일들은 다음에 스테이지한다. 이 기능은 그때 그때 상황에 맞추어 필요한 만큼 사용한다.
						</div>

						<div class="text">
							물론 Git은 이 기능을 건너 뛰는 방법도 제공한다. 커밋 명렁어에 '-a' 옵션을 추가하는 것만으로 쉽게 수정된 모든 파일이 스테이징 영역에 자동으로 추가된다.
						</div>
						
						<div class="center"><img src="images/index2.png" alt="commit only workflow diagram" /></div>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="distributed" href="#distributed">분산</a>
	        </h2>

					<div class="contents">

					  <div class="text">
              			Git을 포함한 모든 분산 SCM의 가장 큰 특징은 당연히 분산된다는 점이다. 이 것은 최신 소스코드를 체크아웃하지 않고 레파지토리 전체를 복사하는 것(Clone)을 말한다.
            </div>
            <div class="text">
           		잘 정리된 워크플로우 없이도 모든 사용자가 메인서버의 풀백업을 가질 수 있다. 그래서 메인서버에 문제가 생겼을때 누구나 메인서버에 푸시할 수 있다. 
            </div>

            <div class="text">
				성능도 빠르다. 보통 SVN은 체크아웃에서만 다른 DSCM들보다 조금 빠르다. (적어도 내가 테스트해본) DSCM들 중에서는 Git이 가장 빠르다.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=200x150&amp;chd=t:120,144,311,64&amp;chds=0,320&amp;chco=4d89f9&amp;chl=git|hg|bzr|svn&amp;chtt=Clone" alt="cloning benchmarks" />
							</td><td style="width: 80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
       	<h2>
        <a name="any-workflow" href="#any-workflow">워크플로우는 Git하기 나름</a>
       	</h2>
				<div class="contents">
					
					<div class="text">
						Git이 대단한 점은 또 있다. Git은 슈퍼 브랜칭 시스템이고 분산 생태계라는 점 때문에 우리가 생각할 수 있는 모든 워크플로우를 쉽게 구현할 수 있다.
					</div>
					
					<h3>Subversion-Style Workflow</h3>
					

					<div class="text">
						매우 일반적으로 사용되는 Git 워크플로우로 중앙집중식<sup>centralized workflow</sup>이 있다. 특히 Subversion같은 중앙집중식 시스템를 사용하다가 넘어온 사람들이 사용한다. 내가 마지막으로 fecth한 후에 아무도 푸시하지 못하도록 할 수 있다. 그래서 모든 개발자가 같은 서버에 푸시하는 중앙집중식 모델도 가능하다.
					</div>
					
					<div class="center"><img src="images/workflow-a.png" alt="subversion-style workflow" /></div><br/>
					
					<h3>Integration Manager Workflow</h3>

					<div class="text">
						또 자주 사용되는 워크플로우로 Integration Manager가 있는 유형이 있다. Integration Manager 한 사람만이 신성한 레파지토리(역자주- 메인 레파지토리)에 커밋할 수 있고 다른 개발자들은 그 레파지토리를 복제한다. 개발자들은 각자의 레파지토리에 커밋하고 관리자에게 자신의 코드를 풀(pull)하도록 요청한다. 이 것은 오픈소스나 GitHub 레파지토리에서 자주 사용되는 개발 모델이다.
					</div>

					<div class="center"><img src="images/workflow-b.png" alt="integration manager workflow" /></div><br/>

					<h3>Dictator and Lieutenants Workflow</h3>

					<div class="text">
						Linux kernel 개발에서 사용하는 모델을 사용할 수 있다. 프로젝트의 특정한 서브시스템('lieutenants')을 담당하는 사람들은 그 서브시스템에서 일어나는 모든 변화를 관리한다. 'dictator'라고 부르는 또 다른 형태의 관리자는 자신의 'lieutenants'에서 발생한 수정내역을 가져다가 신성한 레파지토리에 다시 푸시한다. 그리고 모든 사람들은 이 신성한 레파지토리에서 다시 복제(Clone)한다. 이 것은 리눅스 커널같은 규모가 큰 프로젝트에서 사용된다.
					</div>

					<div class="center"><img src="images/workflow-c.png" alt="dictator and lieutenants workflow" /></div><br/>
					
					<div class="text">
						다시말해서 Git은 매우 유연하다. 이 워크플로우들 중에서 딱 맞는 것을 골라 쓸 수도 있고 섞어서 자신에게 적합한 워크플로우를 만들어 쓸 수도 있다.
					</div>
					
				</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

        <h2>
        <a name="github" href="#github">GitHub</a>
        </h2>
				
				<div class="contents">

          <img style="float:right; padding:10px" src="images/octocat.png" alt="octocat" />

					<div class="text">
						GitHub라는 단락을 추가한 것이 내가 <a href="http://github.com">GitHub</a>에서 일하기 때문에 생긴 <em>편견</em>일 수도 있다. 그러나 너무나 많은 사람들이 Git을 선택한 이유로 GitHub를 들고 있기 때문에 추가했다.
					</div>

					<div class="text">					
						GitHub는 많은 사람들이 Git을 사용하는 이유중 하나다. GitHub는 단순히 호스팅 사이트를 제공하는 것이 아니라 코드를 위한 소셜 네트워크를 제공한다. 사람들은 자신이 하고 있는 일과 유사한 개발자나 프로젝트를 찾는다. 그리고 Git이나 Git을 사용하는 프로젝트와 관련된 매우 활발한 커뮤니티를 만들어서 쉽게 프로젝트를 복제(fork)하거나 참여할(contribute) 수 있다.
					</div>
					
					<div class="text">					
						Git과 다른 SCM을 모두 다루는 서비스들도 있지만 이렇게 사용자 중심이면서 소셜을 타깃으로 하는 서비스는 드문데다가 전적으로 사용자에 기반하는 시스템은 없다. GitHub가 소셜이라는 것은 정말 끈내준다. Git과 GitHub을 함께 사용하면 지금까지 설명한 것들이 잘 어우러져서 정말 오픈소스 프로젝트를 빠르게 개발할 수 있다.
					</div>

					<div class="text">					
						다른 SCM에는 이런 형태의 커뮤니티가 없다.
					</div>

				</div>
	    </div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
        <h2>
        <a name="easy-to-learn" href="#easy-to-learn">Easy to Learn/배우기 쉽다</a>
        </h2>
        
				<div class="contents">
					<div class="text">										
						초창기 Git은 배우기 쉽지 않았다. 그때는 정말이지 분산 SCM을 할 수 있는 툴이 별로 없었다. 그러나 오늘날 Git의 learning curve는 다른 SCM들과 비슷할 뿐만 아니라 심지어 더 쉬운 경우도 있다.
					</div>

					<div class="text">										
						객관적으로 증명하려면 연구라도 해야 하기 때문에 나는 Mercurial과 Git의 기본적인 'help' 메뉴의 차이를 비교 설명하려한다. 두 시스템이 가지고 있는 정말(혹은 거의) 똑같은 명령어는 다른색으로 표기했다. ('hg help'라고 명령어를 실행하면 40여 개의 명령어를 볼 수 있다.)
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Mercurial Help</h3>
<pre>
<span class="compare">add</span>        add the specified files ...
<span class="compare">annotate</span>   show changeset informati...
<span class="compare">clone</span>      make a copy of an existi...
<span class="compare">commit</span>     commit the specified fil...
<span class="compare">diff</span>       diff repository (or sele...
export     dump the header and diff...
<span class="compare">init</span>       create a new repository ...
<span class="compare">log</span>        show revision history of...
<span class="compare">merge</span>      merge working directory ...
parents    show the parents of the ...
<span class="compare">pull</span>       pull changes from the sp...
<span class="compare">push</span>       push changes to the spec...
<span class="compare">remove</span>     remove the specified fil...
serve      export the repository vi...
<span class="compare">status</span>     show changed files in th...
update     update working directory
</pre>

					</td><td valign="top">
						
<h3>Git Help</h3>
<pre>
<span class="compare">add</span>        Add file contents to the index
<span class="compare">bisect</span>     Find the change that introduce...
<span class="compare">branch</span>     List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>      Clone a repository into a new ...
<span class="compare">commit</span>     Record changes to the repository
<span class="compare">diff</span>       Show changes between commits, ...
fetch      Download objects and refs from...
grep       Print lines matching a pattern
<span class="compare">init</span>       Create an empty git repository
<span class="compare">log</span>        Show commit logs
<span class="compare">merge</span>      Join two or more development h...
mv         Move or rename a file, a direc...
<span class="compare">pull</span>       Fetch from and merge with anot...
<span class="compare">push</span>       Update remote refs along with ...
rebase     Forward-port local commits to ...
reset      Reset current HEAD to the spec...
<span class="compare">rm</span>         Remove files from the working ...
show       Show various types of objects
<span class="compare">status</span>     Show the working tree status
<span class="compare">tag</span>        Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">										
					Git 1.6 이전에, 모든 Git 명령어들은 각각의 실행 프로그램으로 돼있었다. 그래서 실행 경로에 등록하면(역자주 - 환경변수 'PATH') 사람들은 매우 헷갈려 했었다. Git은 그 명령어들을 아직도 가지고 있지만 이제는 'git'만 실행할 수 있으면 된다. 그래서 Mercurial과 Git을 보면 명령어들과 도움말이 서로 거의 동일하다. 요즘은 UI 관점에서 시작된 매우 작은 차이가 있을 뿐이다.
				</div>
				
				<div class="text">										
					요즘은 Mercurial이나 Bazaar가 Git보다 배우기 쉽다고 주장하기 어렵다.
				</div>
				
			</div>
				
	    </div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

    <div class="span-24">					
				<div class="expand_collapse_links">
				  <a href="#" class="expand_all">Expand all</a> |
				  <a href="#" class="collapse_all">Collapse all</a>
				</div>
    </div>
    
    <div class="span-24 footer">
			이 사이트는 <a href="http://github.com">GitHubber</a>인 <a href="http://github.com/schacon">Scott Chacon</a>가 만들고 관리하고 있습니다.<br />
			
			만약 이 사이트가 마음에 들지 않을때 타당한 이유를 <a href="mailto:schacon@gmail.com">저</a>에게 보내주시면 수정하겠습니다.
			
			이 사이트의 소스는 <a href="http://github.com/schacon/whygitisbetter">GitHub에</a>있습니다. 이 사이트에 개선할 것이 있으면 주저하지 말고 패치를 보내주세요.
			
			이 사이트의 한글버전은 <a href="mailto:pismute@gmail.com">박창우</a>가 하고 있습니다.
    </div>

    <div class="span-24 footer-lang">
      Also in : 
      <a href="http://de.whygitisbetterthanx.com">German</a>, 
      <a href="http://es.whygitisbetterthanx.com">Spanish</a>, 
      <a href="http://fr.whygitisbetterthanx.com">French</a>, 
      <a href="http://it.whygitisbetterthanx.com">Italian</a>, 
      <a href="http://lol.whygitisbetterthanx.com">Lolcat</a>, 
      <a href="http://nl.whygitisbetterthanx.com">Dutch</a>, 
      <a href="http://no.whygitisbetterthanx.com">Norwegian</a>, 
      <a href="http://pt.whygitisbetterthanx.com">Portuguese</a>, 
      <a href="http://sv.whygitisbetterthanx.com">Swedish</a>,
      <a href="http://zh-cn.whygitisbetterthanx.com">Simplified</a> and
      <a href="http://zh-tw.whygitisbetterthanx.com">Traditional Chinese</a>
    </div>

    <div class="span-24 footer-badges">
      <a href="http://validator.w3.org/check?uri=referer">Valid XHTML</a>
    </div>
	</div>

  <script type="text/javascript">
    $(function() {
      $('.section .contents').hide()
      $('.contents .tweets').hide()

      $('.expand_collapse_links').show()
      $('.expand_collapse_links .expand_all').click(function() {
        $('.section .contents').show()
      })
      $('.expand_collapse_links .collapse_all').click(function() {
        $('.section .contents').hide()
      })

      $('.section h2').click(function() {
        var hidden = $(this).next().is(':hidden')
        $(this).next().slideToggle()
        return hidden
      })

      $('#menu span').css('cursor', 'pointer').click(function() {
        $('.section .contents').hide()
        showSectionsForSCM(this.innerHTML)
        document.location.hash = this.innerHTML
      }) 

      if (document.location.hash) {
        var anchor = document.location.hash.substring(1)
        $('.section h2 a[name=' + anchor + ']').parent('h2').click()
        showSectionsForSCM(anchor)
      }

      function showSectionsForSCM(scm) {
        $('.section .' + scm).parents('.section').find('.contents').show()
      }
    })
  </script>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>
